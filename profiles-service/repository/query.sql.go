// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProfile = `-- name: CreateProfile :one
INSERT INTO Profile (name, gender, birthdate, email, phone)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateProfileParams struct {
	Name      string         `json:"name"`
	Gender    string         `json:"gender"`
	Birthdate pgtype.Date    `json:"birthdate"`
	Email     string         `json:"email"`
	Phone     pgtype.Numeric `json:"phone"`
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProfile,
		arg.Name,
		arg.Gender,
		arg.Birthdate,
		arg.Email,
		arg.Phone,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createRelationship = `-- name: CreateRelationship :one
INSERT INTO Relationship (user1, user2, typ, other)
VALUES ($1, $2, $3, $4)
RETURNING user1, user2, typ, other, created
`

type CreateRelationshipParams struct {
	User1 int32       `json:"user1"`
	User2 int32       `json:"user2"`
	Typ   pgtype.Text `json:"typ"`
	Other pgtype.Text `json:"other"`
}

func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (Relationship, error) {
	row := q.db.QueryRow(ctx, createRelationship,
		arg.User1,
		arg.User2,
		arg.Typ,
		arg.Other,
	)
	var i Relationship
	err := row.Scan(
		&i.User1,
		&i.User2,
		&i.Typ,
		&i.Other,
		&i.Created,
	)
	return i, err
}

const deleteRelationship = `-- name: DeleteRelationship :one


DELETE
FROM Relationship
WHERE user1 = $1
  AND user2 = $2
RETURNING user1, user2, typ, other, created
`

type DeleteRelationshipParams struct {
	User1 int32 `json:"user1"`
	User2 int32 `json:"user2"`
}

// UPDATE Relationship
// SET typ  = COALESCE(sqlc.narg(typ), typ),
//
//	other = COALESCE(sqlc.narg(other), other)
//
// WHERE user1 = sqlc.arg(user1)
//
//	AND user2 = sqlc.arg(user2)
//
// RETURNING *;
func (q *Queries) DeleteRelationship(ctx context.Context, arg DeleteRelationshipParams) (Relationship, error) {
	row := q.db.QueryRow(ctx, deleteRelationship, arg.User1, arg.User2)
	var i Relationship
	err := row.Scan(
		&i.User1,
		&i.User2,
		&i.Typ,
		&i.Other,
		&i.Created,
	)
	return i, err
}

const friendsDetail = `-- name: FriendsDetail :one
select friends_json($1)
`

func (q *Queries) FriendsDetail(ctx context.Context, urid int32) ([]byte, error) {
	row := q.db.QueryRow(ctx, friendsDetail, urid)
	var friends_json []byte
	err := row.Scan(&friends_json)
	return friends_json, err
}

const getFriendRelationships = `-- name: GetFriendRelationships :many
SELECT user1, user2, typ, other, created
FROM Relationship
WHERE user1 = $1
  and typ = 'friend'
`

func (q *Queries) GetFriendRelationships(ctx context.Context, user1 int32) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, getFriendRelationships, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.User1,
			&i.User2,
			&i.Typ,
			&i.Other,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfile = `-- name: GetProfile :one
SELECT id, name, gender, birthdate, email, phone, intro, avatars, avatarl, created
FROM Profile
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetProfile(ctx context.Context, id int32) (Profile, error) {
	row := q.db.QueryRow(ctx, getProfile, id)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birthdate,
		&i.Email,
		&i.Phone,
		&i.Intro,
		&i.Avatars,
		&i.Avatarl,
		&i.Created,
	)
	return i, err
}

const getProfileByEmail = `-- name: GetProfileByEmail :one
SELECT id, name, gender, birthdate, email, phone, intro, avatars, avatarl, created
FROM Profile
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetProfileByEmail(ctx context.Context, email string) (Profile, error) {
	row := q.db.QueryRow(ctx, getProfileByEmail, email)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birthdate,
		&i.Email,
		&i.Phone,
		&i.Intro,
		&i.Avatars,
		&i.Avatarl,
		&i.Created,
	)
	return i, err
}

const getRelationship = `-- name: GetRelationship :one
SELECT user1, user2, typ, other, created
FROM Relationship
WHERE user1 = $1
  AND user2 = $2
LIMIT 1
`

type GetRelationshipParams struct {
	User1 int32 `json:"user1"`
	User2 int32 `json:"user2"`
}

func (q *Queries) GetRelationship(ctx context.Context, arg GetRelationshipParams) (Relationship, error) {
	row := q.db.QueryRow(ctx, getRelationship, arg.User1, arg.User2)
	var i Relationship
	err := row.Scan(
		&i.User1,
		&i.User2,
		&i.Typ,
		&i.Other,
		&i.Created,
	)
	return i, err
}

const getRelationshipsFrom = `-- name: GetRelationshipsFrom :many
SELECT user1, user2, typ, other, created
FROM Relationship
WHERE user1 = $1
`

func (q *Queries) GetRelationshipsFrom(ctx context.Context, user1 int32) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, getRelationshipsFrom, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.User1,
			&i.User2,
			&i.Typ,
			&i.Other,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipsTo = `-- name: GetRelationshipsTo :many
SELECT user1, user2, typ, other, created
FROM Relationship
WHERE user2 = $1
`

func (q *Queries) GetRelationshipsTo(ctx context.Context, user2 int32) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, getRelationshipsTo, user2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.User1,
			&i.User2,
			&i.Typ,
			&i.Other,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestRelationships = `-- name: GetRequestRelationships :many
SELECT user1, user2, typ, other, created
FROM Relationship
WHERE user1 = $1
  and typ = 'request'
`

func (q *Queries) GetRequestRelationships(ctx context.Context, user1 int32) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, getRequestRelationships, user1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.User1,
			&i.User2,
			&i.Typ,
			&i.Other,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mutualFriends = `-- name: MutualFriends :one
select mutual_friends($1, $2)::int[]
`

type MutualFriendsParams struct {
	U1 int32 `json:"u1"`
	U2 int32 `json:"u2"`
}

func (q *Queries) MutualFriends(ctx context.Context, arg MutualFriendsParams) ([]int32, error) {
	row := q.db.QueryRow(ctx, mutualFriends, arg.U1, arg.U2)
	var column_1 []int32
	err := row.Scan(&column_1)
	return column_1, err
}

const searchName = `-- name: SearchName :one
SELECT search_name($1, $2)
`

type SearchNameParams struct {
	U       int32  `json:"u"`
	Pattern string `json:"pattern"`
}

func (q *Queries) SearchName(ctx context.Context, arg SearchNameParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, searchName, arg.U, arg.Pattern)
	var search_name []byte
	err := row.Scan(&search_name)
	return search_name, err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE Profile
SET name      = COALESCE($1, name),
    gender    = COALESCE($2, gender),
    birthdate = COALESCE($3, birthdate),
    phone     = COALESCE($4, phone),
    intro     = COALESCE($5, intro),
    avatarS   = COALESCE($6, avatarS),
    avatarL   = COALESCE($7, avatarL)
WHERE id = $8
RETURNING id, name, gender, birthdate, email, phone, intro, avatars, avatarl, created
`

type UpdateProfileParams struct {
	Name      pgtype.Text    `json:"name"`
	Gender    pgtype.Text    `json:"gender"`
	Birthdate pgtype.Date    `json:"birthdate"`
	Phone     pgtype.Numeric `json:"phone"`
	Intro     pgtype.Text    `json:"intro"`
	Avatars   pgtype.Text    `json:"avatars"`
	Avatarl   pgtype.Text    `json:"avatarl"`
	ID        int32          `json:"id"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (Profile, error) {
	row := q.db.QueryRow(ctx, updateProfile,
		arg.Name,
		arg.Gender,
		arg.Birthdate,
		arg.Phone,
		arg.Intro,
		arg.Avatars,
		arg.Avatarl,
		arg.ID,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birthdate,
		&i.Email,
		&i.Phone,
		&i.Intro,
		&i.Avatars,
		&i.Avatarl,
		&i.Created,
	)
	return i, err
}

const updateRelationship = `-- name: UpdateRelationship :one
insert into Relationship(user1, user2, typ, other)
values ($1, $2, $3, $4)
on conflict (user1, user2) do update set typ   = COALESCE($3, Relationship.typ),
                                         other = COALESCE($4, Relationship.other)
returning user1, user2, typ, other, created
`

type UpdateRelationshipParams struct {
	User1 int32       `json:"user1"`
	User2 int32       `json:"user2"`
	Typ   pgtype.Text `json:"typ"`
	Other pgtype.Text `json:"other"`
}

func (q *Queries) UpdateRelationship(ctx context.Context, arg UpdateRelationshipParams) (Relationship, error) {
	row := q.db.QueryRow(ctx, updateRelationship,
		arg.User1,
		arg.User2,
		arg.Typ,
		arg.Other,
	)
	var i Relationship
	err := row.Scan(
		&i.User1,
		&i.User2,
		&i.Typ,
		&i.Other,
		&i.Created,
	)
	return i, err
}
